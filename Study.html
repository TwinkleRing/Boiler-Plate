<!DOCTYPE html>
<html>
    <body>
    
11월 21일

실행 : npm run start

 몽고 DB 연결하기
1. 몽고 DB 사이트 접속 , 클러스터 만들기, 몽고db 유저 생성
id : hun , password : dudgns941!

mongodb+srv://hun:<password>@boilerplate.oevwc.mongodb.net/<dbname>?retryWrites=true&w=majority

몽구스 : 몽고db를 편하게 사용하게 해주는 툴

user model, user schema 
model은 스키마를 감싸주는 역할을 하는 것
스키마는 어떤 상품에 관련된 글을 작성한다면 , 글을 작성하는 사람이 누구인지, 그 포스트의 이름이 무엇인지, 
그리고 타입은 무엇이고 길이는 얼마까지인지 지정해주는 것이 스키마로 하는 일

 #5 . git 설치
분산 버전 관리 시스템 , git --version

git 저장소 만들기 : git init
git status
git add .
1. working directory => 2. Staging Area => 3. Git repository (Local) => 4. Git repository (Remote)

git ignore

git commit -m " 쓰고 싶은 메세지 "

git push -u origin main

#6 . github 연결 (ssh로 github 연결하기)

ssh 설정하기
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGQoflpfSLwGBKojTBfXtcCgoWvoCNxKMBFOfQmFMGjn dlrmwl15@gmail.com
https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account



echo "# Boiler-Plate" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/TwinkleRing/Boiler-Plate.git
git push -u origin main 


BodyParser & PostMan
npm install body-parser --save 


11월 22일
#8
Nodemon
노드 서버 안에서 뭔가 바꾸면 서버 내리고 다시 구동해야 바뀐 소스가 반영되지만
노드몬 사용하면 서버 내리고 올리지 않아도 변화된 부분을 반영시켜준다.
즉, 프로젝트 폴더의 파일들을 모니터링 하고 있다가 파일이 수정되면 서버를 자동으로 restart 시켜주는 패키지
npm install nodemon --save-dev

dev 붙이면 로컬에서만 사용하겠다.

시작할때 nodemon으로 시작 : npm run backend


#9 비밀 정보를 보호하기
소스 안에 있는 정보 보호하기.
HEROKU에서 관리할수도 있다.

#10
Bcrypt

포스트맨으로 회원가입 했는데.
이게 데이터베이스로 가면 비밀번호가 평문 그대로 저장된다.
그러니 너무 보안성이 약해서 암호화한 다음에 데이터베이스에 저장해야한다.

npm install bcrypt --save
salt를 이용해서 비밀번호를 암호화 한다.


암호화된 데이터 확인 : mongodb에 클러스터 -> Collections
 
# 강의 11 & 12 
로그인 기능 with Bcrypt

1. 데이터베이스에서 요청된 이메일 찾기.
2. 요청한 이메일이 있다면 비밀번호가 같은지 확인한다.
3. 비밀번호까지 맞다면 유저를 위한 토큰을 생성한다.

토큰 생성 위해 JSONWEBTOKEN 설치
npm install jsonwebtoken --save

쿠키파서 설치
npm install cookie-parser --save


11월 23일
# 13 Auth 기능

로그인된 유저만 사용가능한 페이지와 누구나 사용 가능한 페이지

토큰 만들고 그 토큰으로 유저 정보에 넣어주었다.
토큰을 클라이언트의 쿠키에다가도 넣었다.
서버의 유저 데이터베이스에도 넣었다.
이 두가지 토큰으로 서로 맞는지 계속 체크한다.

먼저 클라이언트에서 서버에 쿠키의 토큰을 전달
서버 쪽에서 전달할때 인코드된 토큰을
디코드시키면 user id가 나온다.

그래서 user id를 가진 그 유저 데이터베이스에 토큰이 있다면 인증이 맞다.
없다면 이 유저가 아니므로 글쓰기나 기능 사용 못하게 한다.

auth route 만들기

# 14 로그아웃 기능


11월 26일 
# 15 React js

컴포넌트로 이루어져 있어서 재사용성이 뛰어나다.
모듈화를 통해 다른 애플리케이션에 컴포넌트로 재사용이 가능하다.


Real DOM : 만약 리스트들이 10개 정도 있다면
어떤 1개만 변화가 일어났다.
그때 리얼 돔에서는 전체를 다시 로드 시켜야한다.

virtual DOM : 하나가 업데이트되었으니 하나만 새로 가져온다.
부하가 덜하다.

스냅샷을 찍어놔서 기억해놓고, 업데이트 시키면
virtual DOM이 하나하나 살펴보고
스냅샷 찍어둔 것과 새로 살펴본것의 차이를 분석해서
바뀐 부분만 Real DOM에서 바꿔준다.

# 16 Create-React-App

바벨과 웹팩 설정이 까다로웠다.
그러나 설정 안해도 Create-React-App 커맨드로 자동으로 된다.

바벨 : 자바스크립트를 이용할 때 자바스크립트 es6 ,es7,.... 이 계속 추가되는데
추가된 자바스크립트 메서드들이 오래된 브라우저에서는 안될때가 많다.
최신 자바스크립트 문법을 사용하여도 구동이 되게 변환시켜주는 것이다.

웹팩 : 아주 예전에 웹사이트 만들 때 자바스크립트 파일 몇개와 css, html 로 간단하게 만들었는데
요즘에는 웹사이트 만들 때 라이브러리나 프레임워크들을 많이 사용하게 되다보니
복잡하게 되었다.
복잡하게 된 것들을 웹팩으로 번들(묶는다)시켜준다.
많은 모듈을 합해서 간단하게 만들어준다.


리액트 설치 명령어 : "npx create-react-app ."

npm(node package manager)은 레지스트리 저장소 역할을 한다.
애플리케이션을 킬 때 npm run start나
배포를 할때 npm run build 

npm에 관한 것은 package.json에 있다.

npx를 사용하면 디스크 공간을 낭비하지 않을수 있다.

웹팩은 src 폴더만 관리한다.
public은 해당 x 
그래서 이미지 등은 src에 넣어야한다.


src 폴더 구조 설명

_actions , _reducer => Redux를 위한 폴더들

components/views => 이 안에는 Page들을 넣는다.

components/views/Sections => 이 안에는 해당 페이지에 관련된 css파일이나, component 들을 넣는다.

App.js => Routing 관련 일을 처리한다.
Config.js => 환경 변수같은 것들을 정하는 곳이다.

hoc => Higher Order Component의 약자로 여러 군데에서 쓰일수 있는 것들을 이곳에 넣어줘서 어디서든 쓸수 있게 해줌
utils 랜딩 페이지에 쓰는 페이지가 다른 페이지에서도 여러 곳에서 쓰면 
여러 군데 넣을 필요없이 utils에 넣어둬서 여기저기서 사용할수 있게 한다.

hoc는 다른 컴포넌트를 가지는 function
Auth 컴포넌트 : 접근 자격을 체크
Auth 안에 여러 컴포넌트를 넣어둬서 자동적으로 자격이 되는지 판단해서 다음 액션을 취할수 있게 해준다.




단축어 "rfce" => 컴포넌트 자동완성


리액트에서는 페이지간에 이동할때 react-router-dom 을 사용

cd client => npm install react-router-dom --save




11월 28일

# 21강 데이터 Flow & Axios

데이터 흐름은 유저가 로그인을 하고 싶다면 클라이언트에서 사용자의 이름과 비밀번호를 입력하고 로그인 버튼 클릭
요청이 서버에 가서 서버에서는 데이터베이스에서는 유저의 id가 있는지 찾고
있으면 비밀번호가 맞는지 체크하는 역할을 한다.
비밀번호가 틀리거나 유저가 없다면 클라이언트에 응답을 보낸다.
이전까지는 request를 할때 postman을 사용했다.
이제 클라이언트를 통해 요청을 보내보겠다

Axios를 사용해서 요청을 보낸다.
Axios는 제이쿼리의 ajax같은 역할

cd client -> npm install axios --save


실제 실행 => 1. npm run backend,  터미널 하나를 더 키고 cd client 하고 npm run start

두개의 다른 포트를 가지고 있는 서버는 아무 설정없이 Request를 보낼수 없다.
cross origin Resource Sharing (Cors 정책) 

프록시를 사용하여 해결한다!

npm install http-proxy-middleware --save
 

src/setupProxy.js 생성 후 다시 npm run backend, cd client , npm run start 한다.



# 24강 Concurrently

backend 서버 , frontend 서버 같이 켜기
npm install concurrently --save

package.json에 "dev" : "concurrently \"npm run backend\" \"npm run start --prefix client\"" 추가하기

11월 30일
# 25강 Antd CSS Framework
1. Material UI
2. React Bootstrap 
3. Semantic UI
4. Ant Design 
5. Materiallze


cd client
npm install antd --save
index.js에 import 'antd/dist/antd.css';



# 26강 Redux를
리덕스는 상태 관리 라이브러리로 
state container
리액트에서는 Props와 State가 있다
Props는 properties의 약자로
부모 컴포넌트가 있고 자식 컴포넌트가 안에 들어갈수 있는데
컴포넌트 간에 뭔가 주고받을때는 props를 사용해야한다.
이 props는 부모에서 자식 컴포넌트로 보낼수만 있다

props는 부모 컴포넌트에서 1이라는 값을 주면
이 값은 변할수 없다. immutable하다

다시 부모 컴포넌트에서 줘야 바뀔수 있다

State
부모에서 자식 컴포넌트에 주는게 아니라
컴포넌트 안에서 데이터를 교환, 전달하려면 state를 쓰는데
state는 mutable해서 state를 변하게 할수있다. 다시 re-rendering 된다

상위 컴포넌트에 Comments의 정보를 다 보관하고있다
리덕스가 없으면 상위로 하나하나 타고 올라가야 상태를 관리할수있다
리덕스가 있으면 리덕스 저장소로 Comment들의 상태 하나하나가 변하는걸 쉽게 관리할수있다

Action
무엇이 일어났는지 설명하는 객체

Reducer

state는 2에서 3으로 변하고 3에서 4로 변하고 변할수 있다
그래서 Action을 함으로 인해서 원래 3이였던 State가 액션으로 4로 변했다. 
이런 걸 설명해주는 게 Reducer이다.
Action의 Object를 받은 후 변해진 state를 return하는게 Reducer!

Store 

애플리케이션의 state를 감싸주는 역할로
이 안에는 여러 메서드가 있어서 이를 이용해서 
state를 관리할 수 있다.

# 27

Redux & Redux Middleware 설치

cd client 
npm install redux react-redux redux-promise redux-thunk --save

redux-promise redux-thunk는 redux를 잘 쓸수있게 도와준다.
redux는 redux store가 있는데 그 안에 모든 state를 관리한다.
이 store에 state를 변경하고 싶으면 Dispatch(action)을 사용
근데 Action은 객체 형식이여야 한다
그런데 store에서 언제나 객체 형식을 받는게 아니라
어쩔때는 promise 형식을 받을 때도 있고 Functions 형식을 받을 때도 있다
redux store는 객체 형식만 받으니까

redux-promise redux-thunk 를 middleware로 받아서
thunk는 Dispatch한테 어떻게 functions를 받는 방법을 알려주는 것이고
promise는 Dispatch한테 promiss를 받을때 어떻게 대처하는지 알려주는 것이다.



# 28 React Hooks
React Component에는 Class Component와 functional Component

Class Component는 더 많은 기능 사용,
코드가 길어지고 복잡하다. 성능적으로 느림

Functional Component은 제공 하는 기능이 한정적
코드가 간단하고, 성능이 좀 더 월등

Class Component를 사용하다가
React에서 Hooks를 이용해서
functional Component로 여러 기능을 사용할 수 있게됨.


라이프 사이클
1. constructor로 state 부여
2. render로 jsx로 DOM에 맞게 화면에 rendering
3. componentDidMount로 데이터 가져오거나 하고싶은것들을 해준다.

위의 동작을 Hook으로 구현하겠다.

12월 1일

# 29 로그인 페이지


    </body>
</html>